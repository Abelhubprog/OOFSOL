# 🤖 Multi-Model AI Agent Architecture for OOF Moments

## Deep Conceptualization

### Core Philosophy
Create an intelligent agent ecosystem that leverages the strengths of different AI models while optimizing for cost, speed, and accuracy. Each agent specializes in specific tasks, with smart routing based on complexity and requirements.

## 🏗️ Agent Architecture Overview

```typescript
// Agent Hierarchy & Specialization
interface AgentEcosystem {
  orchestrator: OrchestratorAgent;     // LangGraph coordinator
  router: ModelRoutingAgent;           // Smart model selection
  dataCollector: WalletDataAgent;      // Blockchain data fetching
  analyzer: WalletAnalysisAgent;       // Transaction analysis
  oofDetector: OOFMomentAgent;         // Pattern recognition
  cardDesigner: CardDesignAgent;       // Creative generation
  validator: QualityAssuranceAgent;    // Output validation
}
```

## 🧠 Model Specialization Strategy

### Tier 1: Heavy Lifting (Complex Analysis)
- **Claude 3.5 Sonnet**: Complex reasoning, nuanced analysis
- **GPT-4**: Creative narratives, psychological insights
- **Perplexity**: Real-time crypto knowledge, market context

### Tier 2: Efficient Processing (Routine Tasks)  
- **Gemini Pro**: Balanced performance, good reasoning
- **OpenAI GPT-3.5**: Fast creative tasks

### Tier 3: Cost-Effective (High Volume)
- **DeepSeek**: Data processing, pattern matching
- **Qwen**: Classification, simple analysis

## 📋 Modified Repository Structure

```
oof-ai-agents/
├── src/
│   ├── agents/
│   │   ├── orchestrator/
│   │   │   ├── coordinator.ts
│   │   │   └── workflow_graph.ts
│   │   ├── routing/
│   │   │   ├── model_router.ts
│   │   │   ├── cost_optimizer.ts
│   │   │   └── fallback_handler.ts
│   │   ├── data/
│   │   │   ├── wallet_fetcher.ts
│   │   │   ├── solana_parser.ts
│   │   │   └── cache_manager.ts
│   │   ├── analysis/
│   │   │   ├── transaction_analyzer.ts
│   │   │   ├── pattern_detector.ts
│   │   │   └── performance_calculator.ts
│   │   ├── oof_detection/
│   │   │   ├── paper_hands_detector.ts
│   │   │   ├── dust_identifier.ts
│   │   │   └── gains_analyzer.ts
│   │   ├── design/
│   │   │   ├── narrative_generator.ts
│   │   │   ├── visual_designer.ts
│   │   │   └── card_assembler.ts
│   │   └── validation/
│   │       ├── quality_checker.ts
│   │       └── accuracy_validator.ts
│   ├── models/
│   │   ├── providers/
│   │   │   ├── openai_client.ts
│   │   │   ├── claude_client.ts
│   │   │   ├── gemini_client.ts
│   │   │   ├── perplexity_client.ts
│   │   │   ├── deepseek_client.ts
│   │   │   └── qwen_client.ts
│   │   ├── interfaces/
│   │   │   ├── model_interface.ts
│   │   │   └── response_types.ts
│   │   └── cost_tracker.ts
│   ├── blockchain/
│   │   ├── solana_client.ts
│   │   ├── transaction_parser.ts
│   │   └── token_analyzer.ts
│   ├── workflows/
│   │   ├── oof_generation_flow.ts
│   │   ├── batch_processing.ts
│   │   └── real_time_analysis.ts
│   └── utils/
│       ├── prompt_templates.ts
│       ├── error_handling.ts
│       └── monitoring.ts
├── config/
│   ├── model_config.ts
│   ├── routing_rules.ts
│   └── cost_limits.ts
└── tests/
    ├── unit/
    ├── integration/
    └── e2e/
```

## 🔄 LangGraph Workflow Implementation

### 1. Orchestrator Agent (Modified from Gemini Quickstart)

```typescript
// src/agents/orchestrator/workflow_graph.ts
import { StateGraph, END } from "@langchain/langgraph";
import { OOFGenerationState } from "./state";

interface OOFGenerationState {
  walletAddress: string;
  rawData?: BlockchainData;
  analyzedData?: AnalysisResult;
  oofMoments?: OOFMoment[];
  designedCards?: OOFCard[];
  validatedOutput?: ValidatedCards;
  errors?: string[];
  metadata: {
    modelUsage: ModelUsageTracker;
    costs: CostBreakdown;
    performance: PerformanceMetrics;
  };
}

class OOFOrchestrator {
  private graph: StateGraph<OOFGenerationState>;
  private modelRouter: ModelRoutingAgent;

  constructor() {
    this.modelRouter = new ModelRoutingAgent();
    this.graph = this.buildWorkflow();
  }

  private buildWorkflow(): StateGraph<OOFGenerationState> {
    const workflow = new StateGraph<OOFGenerationState>({
      channels: {
        walletAddress: "string",
        rawData: "object",
        analyzedData: "object", 
        oofMoments: "array",
        designedCards: "array",
        validatedOutput: "object",
        errors: "array",
        metadata: "object"
      }
    });

    // Define nodes
    workflow.addNode("validate_input", this.validateInput.bind(this));
    workflow.addNode("fetch_data", this.fetchWalletData.bind(this));
    workflow.addNode("analyze_transactions", this.analyzeTransactions.bind(this));
    workflow.addNode("detect_oof_moments", this.detectOOFMoments.bind(this));
    workflow.addNode("design_cards", this.designCards.bind(this));
    workflow.addNode("validate_output", this.validateOutput.bind(this));
    workflow.addNode("handle_error", this.handleError.bind(this));

    // Define edges
    workflow.addEdge("validate_input", "fetch_data");
    workflow.addEdge("fetch_data", "analyze_transactions");
    workflow.addEdge("analyze_transactions", "detect_oof_moments");
    workflow.addEdge("detect_oof_moments", "design_cards");
    workflow.addEdge("design_cards", "validate_output");
    workflow.addEdge("validate_output", END);

    // Conditional edges for error handling
    workflow.addConditionalEdges(
      "validate_input",
      (state) => state.errors?.length ? "handle_error" : "fetch_data"
    );

    workflow.setEntryPoint("validate_input");

    return workflow.compile();
  }

  async generateOOFMoments(walletAddress: string): Promise<ValidatedCards> {
    const initialState: OOFGenerationState = {
      walletAddress,
      metadata: {
        modelUsage: new ModelUsageTracker(),
        costs: new CostBreakdown(),
        performance: new PerformanceMetrics()
      }
    };

    const result = await this.graph.invoke(initialState);
    return result.validatedOutput!;
  }

  // Node implementations
  private async validateInput(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    if (!state.walletAddress || !this.isValidSolanaAddress(state.walletAddress)) {
      return { errors: ["Invalid Solana wallet address"] };
    }
    return {};
  }

  private async fetchWalletData(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    const dataAgent = new WalletDataAgent();
    const rawData = await dataAgent.fetchComprehensiveData(state.walletAddress);
    return { rawData };
  }

  private async analyzeTransactions(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    const analysisAgent = new WalletAnalysisAgent(this.modelRouter);
    const analyzedData = await analysisAgent.analyzeTransactionHistory(state.rawData!);
    return { analyzedData };
  }

  private async detectOOFMoments(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    const detectionAgent = new OOFMomentAgent(this.modelRouter);
    const oofMoments = await detectionAgent.identifyOOFMoments(state.analyzedData!);
    return { oofMoments };
  }

  private async designCards(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    const designAgent = new CardDesignAgent(this.modelRouter);
    const designedCards = await designAgent.createUniqueCards(
      state.oofMoments!,
      state.walletAddress
    );
    return { designedCards };
  }

  private async validateOutput(state: OOFGenerationState): Promise<Partial<OOFGenerationState>> {
    const validator = new QualityAssuranceAgent(this.modelRouter);
    const validatedOutput = await validator.validateCards(state.designedCards!);
    return { validatedOutput };
  }
}
```

### 2. Smart Model Routing Agent

```typescript
// src/agents/routing/model_router.ts
interface ModelConfig {
  name: string;
  provider: string;
  costPerToken: number;
  maxTokens: number;
  strengths: string[];
  weaknesses: string[];
  reliability: number;
}

interface TaskRequirements {
  complexity: 'low' | 'medium' | 'high';
  creativity: 'low' | 'medium' | 'high';
  accuracy: 'low' | 'medium' | 'high';
  speed: 'low' | 'medium' | 'high';
  maxCost: number;
  fallbackRequired: boolean;
}

class ModelRoutingAgent {
  private models: Map<string, ModelConfig>;
  private costTracker: CostTracker;
  private performanceMonitor: PerformanceMonitor;

  constructor() {
    this.models = this.initializeModels();
    this.costTracker = new CostTracker();
    this.performanceMonitor = new PerformanceMonitor();
  }

  private initializeModels(): Map<string, ModelConfig> {
    return new Map([
      ['deepseek-coder', {
        name: 'deepseek-coder',
        provider: 'deepseek',
        costPerToken: 0.00002,
        maxTokens: 4096,
        strengths: ['code analysis', 'pattern recognition', 'data processing'],
        weaknesses: ['creativity', 'nuanced reasoning'],
        reliability: 0.85
      }],
      ['qwen-plus', {
        name: 'qwen-plus', 
        provider: 'qwen',
        costPerToken: 0.00003,
        maxTokens: 8192,
        strengths: ['classification', 'structured analysis', 'mathematical reasoning'],
        weaknesses: ['creative writing', 'emotional intelligence'],
        reliability: 0.82
      }],
      ['gemini-pro', {
        name: 'gemini-pro',
        provider: 'google',
        costPerToken: 0.0005,
        maxTokens: 32768,
        strengths: ['balanced reasoning', 'multimodal', 'context understanding'],
        weaknesses: ['specialized domains'],
        reliability: 0.88
      }],
      ['gpt-3.5-turbo', {
        name: 'gpt-3.5-turbo',
        provider: 'openai',
        costPerToken: 0.002,
        maxTokens: 4096,
        strengths: ['creative writing', 'general reasoning', 'speed'],
        weaknesses: ['complex analysis', 'accuracy'],
        reliability: 0.85
      }],
      ['gpt-4o', {
        name: 'gpt-4o',
        provider: 'openai', 
        costPerToken: 0.01,
        maxTokens: 8192,
        strengths: ['complex reasoning', 'creativity', 'accuracy'],
        weaknesses: ['cost', 'speed'],
        reliability: 0.93
      }],
      ['claude-3.5-sonnet', {
        name: 'claude-3.5-sonnet',
        provider: 'anthropic',
        costPerToken: 0.015,
        maxTokens: 200000,
        strengths: ['complex analysis', 'nuanced reasoning', 'safety'],
        weaknesses: ['cost', 'availability'],
        reliability: 0.95
      }],
      ['perplexity-sonar', {
        name: 'perplexity-sonar',
        provider: 'perplexity',
        costPerToken: 0.005,
        maxTokens: 4096,
        strengths: ['real-time knowledge', 'research', 'factual accuracy'],
        weaknesses: ['creative tasks', 'reasoning'],
        reliability: 0.90
      }]
    ]);
  }

  async selectBestModel(
    task: string,
    requirements: TaskRequirements,
    context?: any
  ): Promise<{ primary: string; fallback?: string }> {
    
    const candidates = Array.from(this.models.entries())
      .map(([name, config]) => ({
        name,
        config,
        score: this.calculateModelScore(config, requirements, task)
      }))
      .filter(candidate => candidate.score > 0)
      .sort((a, b) => b.score - a.score);

    if (candidates.length === 0) {
      throw new Error('No suitable model found for task');
    }

    const primary = candidates[0].name;
    const fallback = requirements.fallbackRequired && candidates.length > 1 
      ? candidates[1].name 
      : undefined;

    // Track selection for learning
    this.performanceMonitor.recordSelection(task, primary, requirements);

    return { primary, fallback };
  }

  private calculateModelScore(
    config: ModelConfig,
    requirements: TaskRequirements,
    task: string
  ): number {
    let score = 0;

    // Base reliability score
    score += config.reliability * 100;

    // Task-specific strength matching
    if (task.includes('analysis') && config.strengths.includes('complex analysis')) {
      score += 50;
    }
    if (task.includes('creative') && config.strengths.includes('creativity')) {
      score += 50;
    }
    if (task.includes('pattern') && config.strengths.includes('pattern recognition')) {
      score += 40;
    }

    // Cost efficiency
    const costPerRequest = config.costPerToken * 1000; // Estimate 1k tokens
    if (costPerRequest <= requirements.maxCost) {
      score += (requirements.maxCost - costPerRequest) * 10;
    } else {
      score -= 100; // Penalty for exceeding budget
    }

    // Performance requirements
    if (requirements.complexity === 'high' && config.strengths.includes('complex reasoning')) {
      score += 30;
    }
    if (requirements.speed === 'high' && config.provider === 'deepseek') {
      score += 20;
    }

    return Math.max(0, score);
  }

  async executeWithModel(
    modelName: string,
    prompt: string,
    options?: any
  ): Promise<ModelResponse> {
    const config = this.models.get(modelName);
    if (!config) {
      throw new Error(`Model ${modelName} not found`);
    }

    const startTime = Date.now();
    const client = this.getModelClient(config.provider);
    
    try {
      const response = await client.complete(prompt, {
        model: modelName,
        maxTokens: options?.maxTokens || config.maxTokens,
        ...options
      });

      const endTime = Date.now();
      const usage = {
        model: modelName,
        tokens: response.usage?.totalTokens || 0,
        cost: (response.usage?.totalTokens || 0) * config.costPerToken,
        latency: endTime - startTime
      };

      this.costTracker.recordUsage(usage);
      this.performanceMonitor.recordSuccess(modelName, usage.latency);

      return response;

    } catch (error) {
      this.performanceMonitor.recordError(modelName, error as Error);
      throw error;
    }
  }

  private getModelClient(provider: string): ModelClient {
    switch (provider) {
      case 'openai': return new OpenAIClient();
      case 'anthropic': return new ClaudeClient();
      case 'google': return new GeminiClient();
      case 'perplexity': return new PerplexityClient();
      case 'deepseek': return new DeepSeekClient();
      case 'qwen': return new QwenClient();
      default: throw new Error(`Unknown provider: ${provider}`);
    }
  }
}
```

### 3. Specialized OOF Detection Agent

```typescript
// src/agents/oof_detection/oof_moment_agent.ts
class OOFMomentAgent {
  private modelRouter: ModelRoutingAgent;
  private detectionStrategies: Map<string, DetectionStrategy>;

  constructor(modelRouter: ModelRoutingAgent) {
    this.modelRouter = modelRouter;
    this.detectionStrategies = this.initializeStrategies();
  }

  async identifyOOFMoments(analysisData: AnalysisResult): Promise<OOFMoment[]> {
    const oofMoments: OOFMoment[] = [];

    // Parallel detection of different OOF types
    const [paperHandsMoments, dustMoments, gainsMoments] = await Promise.all([
      this.detectPaperHands(analysisData),
      this.detectDustCollections(analysisData),
      this.detectBigGains(analysisData)
    ]);

    oofMoments.push(...paperHandsMoments, ...dustMoments, ...gainsMoments);

    // Rank and select top 3 most significant moments
    return this.rankAndSelectTop3(oofMoments);
  }

  private async detectPaperHands(data: AnalysisResult): Promise<OOFMoment[]> {
    const strategy = this.detectionStrategies.get('paperHands')!;
    
    // Use cost-effective model for initial filtering
    const { primary } = await this.modelRouter.selectBestModel(
      'pattern_detection_paper_hands',
      {
        complexity: 'medium',
        creativity: 'low',
        accuracy: 'high',
        speed: 'high',
        maxCost: 0.001,
        fallbackRequired: true
      }
    );

    const candidateTransactions = data.transactions.filter(tx => 
      strategy.preFilter(tx)
    );

    // Use more powerful model for detailed analysis
    const analysisPrompt = this.buildPaperHandsAnalysisPrompt(candidateTransactions, data);
    
    const { primary: analysisModel } = await this.modelRouter.selectBestModel(
      'complex_analysis_paper_hands',
      {
        complexity: 'high',
        creativity: 'medium',
        accuracy: 'high',
        speed: 'medium',
        maxCost: 0.01,
        fallbackRequired: true
      }
    );

    const response = await this.modelRouter.executeWithModel(
      analysisModel,
      analysisPrompt
    );

    return this.parsePaperHandsResponse(response.content);
  }

  private buildPaperHandsAnalysisPrompt(
    transactions: Transaction[], 
    context: AnalysisResult
  ): string {
    return `
# Paper Hands OOF Moment Detection

## Context
Wallet: ${context.walletAddress}
Total Trades: ${context.totalTrades}
Win Rate: ${context.winRate}%
Avg Hold Time: ${context.avgHoldTime} days

## Candidate Transactions
${transactions.map(tx => `
Token: ${tx.tokenSymbol}
Buy: $${tx.buyPrice} (${new Date(tx.buyTimestamp).toLocaleDateString()})
Sell: $${tx.sellPrice} (${new Date(tx.sellTimestamp).toLocaleDateString()})
Current: $${tx.currentPrice}
Amount: ${tx.amount}
Potential if held: $${(tx.amount * tx.currentPrice).toFixed(2)}
Missed gains: $${((tx.amount * tx.currentPrice) - (tx.amount * tx.sellPrice)).toFixed(2)}
`).join('\n')}

## Task
Identify the most significant "paper hands" moments where the user sold too early and missed substantial gains.

Consider:
1. Absolute missed dollar amount
2. Percentage gains missed  
3. Time held vs optimal hold time
4. Market context at time of sale
5. Psychological factors (panic selling, FOMO, etc.)

For each significant moment, provide:
- Narrative explanation of what happened
- Emotional impact assessment
- Specific numbers (bought at X, sold at Y, now worth Z)
- A memorable quote that captures the feeling
- Rarity assessment (common, rare, epic, legendary)

Return as JSON array of OOF moments.
    `;
  }

  private async detectDustCollections(data: AnalysisResult): Promise<OOFMoment[]> {
    // Similar implementation for dust detection
    // Use DeepSeek/Qwen for initial filtering, Claude for analysis
  }

  private async detectBigGains(data: AnalysisResult): Promise<OOFMoment[]> {
    // Similar implementation for gains detection  
    // Use GPT-4 for creative celebration narratives
  }

  private rankAndSelectTop3(moments: OOFMoment[]): OOFMoment[] {
    return moments
      .sort((a, b) => this.calculateSignificanceScore(b) - this.calculateSignificanceScore(a))
      .slice(0, 3)
      .map((moment, index) => ({
        ...moment,
        rank: index + 1,
        category: index === 0 ? 'legendary' : index === 1 ? 'epic' : 'rare'
      }));
  }

  private calculateSignificanceScore(moment: OOFMoment): number {
    // Complex scoring algorithm considering:
    // - Dollar impact
    // - Percentage impact  
    // - Uniqueness
    // - Emotional weight
    // - Meme potential
    return moment.dollarImpact * 0.4 + 
           moment.percentageImpact * 0.3 + 
           moment.uniquenessScore * 0.2 + 
           moment.memeScore * 0.1;
  }
}
```

### 4. Creative Card Design Agent

```typescript
// src/agents/design/card_design_agent.ts
class CardDesignAgent {
  private modelRouter: ModelRoutingAgent;
  private visualGenerator: VisualElementGenerator;

  constructor(modelRouter: ModelRoutingAgent) {
    this.modelRouter = modelRouter;
    this.visualGenerator = new VisualElementGenerator();
  }

  async createUniqueCards(
    oofMoments: OOFMoment[], 
    walletAddress: string
  ): Promise<OOFCard[]> {
    
    const cardPromises = oofMoments.map(async (moment, index) => {
      // Use creative models for narrative generation
      const narrative = await this.generateNarrative(moment, walletAddress);
      
      // Use cost-effective models for visual elements
      const visualElements = await this.generateVisualElements(moment, index);
      
      // Combine into final card
      return this.assembleCard(moment, narrative, visualElements, walletAddress);
    });

    return Promise.all(cardPromises);
  }

  private async generateNarrative(
    moment: OOFMoment, 
    walletAddress: string
  ): Promise<CardNarrative> {
    
    const { primary } = await this.modelRouter.selectBestModel(
      'creative_narrative_generation',
      {
        complexity: 'high',
        creativity: 'high', 
        accuracy: 'medium',
        speed: 'medium',
        maxCost: 0.05,
        fallbackRequired: true
      }
    );

    const prompt = this.buildNarrativePrompt(moment, walletAddress);
    const response = await this.modelRouter.executeWithModel(primary, prompt);
    
    return this.parseNarrativeResponse(response.content);
  }

  private buildNarrativePrompt(moment: OOFMoment, walletAddress: string): string {
    return `
# OOF Moment Card Narrative Generation

## Moment Details
Type: ${moment.type}
Token: ${moment.tokenSymbol}
Impact: $${moment.dollarImpact} (${moment.percentageImpact}%)
Wallet: ${walletAddress.slice(0, 8)}...
Context: ${moment.context}

## Task
Create a unique, personalized narrative for this specific OOF moment that:

1. **Captures the specific pain/joy** of this exact situation
2. **Uses crypto trading psychology** and memecoin culture references  
3. **Includes specific numbers** from this trade
4. **Has a memorable quote** that traders will relate to
5. **Shows empathy** while being entertaining

## Style Guidelines
- Tone: Humorous but empathetic
- Length: 2-3 sentences for story, 1 sentence for quote
- Language: Crypto twitter speak mixed with universal emotions
- Avoid: Generic statements, financial advice

## Examples of Good OOF Narratives
"When BONK started pumping, you bought at $0.000015. The community was electric, the memes were flowing, but when it dipped to $0.000012, fear took over. You sold everything, only to watch it rocket to $0.001500 the next week. 'My hands turned to tissue paper the moment I saw red.'"

Now create a similarly personal narrative for this moment.

Return JSON: {
  "title": "Creative title for the card",
  "narrative": "2-3 sentence story",
  "quote": "Memorable quote from the user's perspective", 
  "mood": "emotional tone (regret/celebration/pain/joy)",
  "hashtags": ["#relevant", "#hashtags"]
}
    `;
  }

  private async generateVisualElements(
    moment: OOFMoment, 
    cardIndex: number
  ): Promise<VisualElements> {
    
    // Use cheaper model for visual element generation
    const { primary } = await this.modelRouter.selectBestModel(
      'visual_element_generation',
      {
        complexity: 'low',
        creativity: 'medium',
        accuracy: 'medium', 
        speed: 'high',
        maxCost: 0.002,
        fallbackRequired: false
      }
    );

    const walletHash = moment.walletAddress.slice(-8);
    const uniqueSeed = `${walletHash}-${cardIndex}-${moment.type}`;
    
    return this.visualGenerator.generateUniqueElements(moment, uniqueSeed);
  }

  private assembleCard(
    moment: OOFMoment,
    narrative: CardNarrative, 
    visual: VisualElements,
    walletAddress: string
  ): OOFCard {
    return {
      id: `${moment.type}-${walletAddress.slice(-8)}-${Date.now()}`,
      type: moment.type,
      title: narrative.title,
      narrative: narrative.narrative,
      quote: narrative.quote,
      tokenData: {
        symbol: moment.tokenSymbol,
        name: moment.tokenName,
        address: moment.tokenAddress,
        entryPrice: moment.entryPrice,
        exitPrice: moment.exitPrice,
        currentPrice: moment.currentPrice,
        amount: moment.amount
      },
      stats: {
        missedGains: moment.type === 'paperHands' ? moment.dollarImpact : undefined,
        lossAmount: moment.type === 'dust' ? moment.dollarImpact : undefined,
        gainAmount: moment.type === 'bigGains' ? moment.dollarImpact : undefined,
        percentage: moment.percentageImpact
      },
      visualElements: visual,
      metadata: {
        rarity: moment.category,
        traits: this.generateTraits(moment, narrative),
        generatedAt: Date.now(),
        walletAddress: walletAddress,
        aiModelsUsed: this.getModelUsageHistory()
      }
    };
  }
}
```

### 5. Cost Optimization & Monitoring

```typescript
// src/models/cost_tracker.ts
class CostTracker {
  private dailyBudget: number = 100; // $100 daily budget
  private currentSpend: number = 0;
  private usageLog: ModelUsage[] = [];

  recordUsage(usage: ModelUsage): void {
    this.usageLog.push({
      ...usage,
      timestamp: Date.now()
    });
    
    this.currentSpend += usage.cost;
    
    if (this.currentSpend > this.dailyBudget * 0.8) {
      this.triggerCostAlert('approaching_limit');
    }
    
    if (this.currentSpend > this.dailyBudget) {
      this.triggerCostAlert('exceeded_limit');
    }
  }

  getOptimalModelForBudget(remainingBudget: number): string[] {
    const costEfficient = ['deepseek-coder', 'qwen-plus', 'gemini-pro'];
    const premium = ['gpt-4o', 'claude-3.5-sonnet'];
    
    return remainingBudget > 10 ? [...costEfficient, ...premium] : costEfficient;
  }

  generateCostReport(): CostReport {
    const today = new Date().toDateString();
    const todayUsage = this.usageLog.filter(
      log => new Date(log.timestamp).toDateString() === today
    );

    return {
      totalCost: this.currentSpend,
      modelBreakdown: this.calculateModelCosts(todayUsage),
      efficiency: this.calculateEfficiency(todayUsage),
      recommendations: this.generateOptimizationRecommendations()
    };
  }
}
```

### 6. Integration with Frontend

```typescript
// src/api/oof_generation_api.ts
import { OOFOrchestrator } from '../agents/orchestrator/coordinator';

export class OOFGenerationAPI {
  private orchestrator: OOFOrchestrator;

  constructor() {
    this.orchestrator = new OOFOrchestrator();
  }

  async generateOOFMoments(walletAddress: string): Promise<{
    cards: OOFCard[];
    metadata: GenerationMetadata;
  }> {
    try {
      const result = await this.orchestrator.generateOOFMoments(walletAddress);
      
      return {
        cards: result.cards,
        metadata: {
          processingTime: result.metadata.performance.totalTime,
          modelsUsed: result.metadata.modelUsage.breakdown,
          totalCost: result.metadata.costs.total,
          accuracy: result.metadata.quality.accuracy
        }
      };
      
    } catch (error) {
      throw new APIError('Failed to generate OOF moments', error);
    }
  }

  async getGenerationStatus(sessionId: string): Promise<GenerationStatus> {
    // Real-time status updates for long-running operations
  }

  async getBatchGenerationResults(sessionIds: string[]): Promise<BatchResults> {
    // Batch processing for multiple wallets
  }
}
```

## 🎯 Key Benefits of This Architecture

### 1. **Cost Optimization**
- Use DeepSeek/Qwen for routine processing (90% cost reduction)
- Reserve GPT-4/Claude for complex reasoning 
- Real-time budget monitoring and model switching

### 2. **Quality Assurance**
- Multi-model validation
- Ensemble approaches for critical decisions
- Fallback mechanisms for reliability

### 3. **Scalability** 
- Parallel processing of different OOF types
- Batch operations for high volume
- Caching and optimization

### 4. **Uniqueness**
- Each wallet gets personalized analysis
- AI-generated narratives, not templates
- Visual elements based on wallet characteristics

### 5. **Speed**
- Smart routing to fastest models for time-critical tasks
- Parallel execution where possible
- Caching of repeated operations

This architecture creates a sophisticated AI agent ecosystem that can efficiently analyze wallets, detect OOF moments, and generate unique cards while optimizing for cost, speed, and quality.